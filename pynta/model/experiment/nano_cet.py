# -*- coding: utf-8 -*-
"""
    nano_cet.py
    ===========
    Capillary Electrokinetic Tracking of Nanoparticles (nanoCET) is a technique that allows to characterize very small
    objects thanks to calculating their diffusion properties inside a capillary. The main advantage of the technique
    is that objects remain in the Field of View for extended periods of time and thus their properties can be quantified
    with a high accuracy.


    :copyright:  Aquiles Carattino <aquiles@aquicarattino.com>
    :license: AGPLv3, see LICENSE for more details
"""
from .base_experiment import BaseExperiment
from pynta.tools import WorkerThread
from multiprocessing import Queue


class NanoCET(BaseExperiment):
    """ Experiment class for performing a nanoCET measurement."""
    def __init__(self, filename=None):
        super().__init__()  # Initialize base class

        self.acquiring = False  # Status of the acquisition
        self.config = None  # Dictionary holding all the configuration parameters

        self.load_configuration(filename)

    def load_configuration(self, filename):
        """ Loads the configuration file in YAML format.

        :param str filename: full path to where the configuration file is located.
        :raises FileNotFoundError: if the file does not exist.
        """
        pass

    def initialize_camera(self):
        """ Initializes the camera to be used to acquire data. The information on the camera should be provided in the
        configuration file and loaded with :meth:`~self.load_configuration`. """
        pass

    def set_roi(self, x, y, width, height):
        """ Sets the region of interest of the camera, provided that the camera supports cropping. All the technicalities
        should be addressed on the camera model, not in this method.

        :param int x: horizontal position for the start of the cropping
        :param int y: vertical position for the start of the cropping
        :param int width: width in pixels for cropping
        :param int height: height in pixels for the cropping
        :raises ValueError: if either dimension of the cropping goes out of the camera total amount of pixels
        :returns: The final cropping dimensions, it may be that the camera limits the user desires
        """
        pass

    def clear_roi(self):
        """ Clears the region of interest and returns to the full frame of the camera.
        """
        pass

    def snap(self):
        """ Snap a single frame
        :returns: numpy 2D array with the image (?)
        """
        self.camera.configure(self.config['camera'])
        self.snap_worker = WorkerThread(target=self.camera.snap)

    def save_image(self):
        """ Saves the last acquired image.
        """
        pass

    def start_free_run(self):
        """ Starts continuous acquisition from the camera, but it is not being saved.

        .. TODO:: Decide if this is the best strategy or it would be better to have a separate buffer method as was the  case for UUTrack.
        """
        pass

    def start_movie(self):
        """ Starts the acquisition of a movie
        """
        pass

    def stop_movie(self):
        """ Stops the acquisition of the movie.
        """
        pass

    def save_movie(self):
        """ Saves the movie to a file.
        """
        pass

    def stop_save_movie(self):
        """ Stops saving to a movie.
        """
        pass

    def empty_queue(self):
        """ Empties the queue where the data from the movie is being stored.
        """
        pass

    def get_data(self):
        """ Gets the data generated by the working thread.
        """
        pass

