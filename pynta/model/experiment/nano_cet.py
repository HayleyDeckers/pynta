# -*- coding: utf-8 -*-
"""
    nano_cet.py
    ===========
    Capillary Electrokinetic Tracking of Nanoparticles (nanoCET) is a technique that allows to characterize very small
    objects thanks to calculating their diffusion properties inside a capillary. The main advantage of the technique
    is that objects remain in the Field of View for extended periods of time and thus their properties can be quantified
    with a high accuracy.


    :copyright:  Aquiles Carattino <aquiles@aquicarattino.com>
    :license: AGPLv3, see LICENSE for more details
"""
import importlib

import yaml
from multiprocessing import Queue

from .base_experiment import BaseExperiment
from pynta.tools import WorkerThread
from pynta.util import get_logger



class NanoCET(BaseExperiment):
    """ Experiment class for performing a nanoCET measurement."""
    def __init__(self, filename=None):
        super().__init__()  # Initialize base class

        self.acquiring = False  # Status of the acquisition
        self.config = None  # Dictionary holding all the configuration parameters
        self.camera = None # This will hold the model for the camera

        self.logger = get_logger(name=__name__)


    def initialize_camera(self):
        """ Initializes the camera to be used to acquire data. The information on the camera should be provided in the
        configuration file and loaded with :meth:`~self.load_configuration`. It will load the camera assuming
        it is located in pynta/model/cameras/[model].

        .. todo:: Define how to load models from outside of pynta. E.g. from a user-specified folder.
        """
        try:
            self.logger.debug('Importing camera model {}'.format(self.config['Camera']['model']))
            camera_model_to_import = 'pynta.model.cameras.' + self.config['Camera']['model']
            cam_module = importlib.import_module(camera_model_to_import)
        except ModuleNotFoundError:
            self.logger.error('The model {} for the camera was not found'.format(self.config['Camera']['model']))
            raise
        except:
            self.logger.exception('Unhandled exception')
            raise

        cam_init_arguments = self.config['Camera']['init']

        if 'extra_args' in self.config['Camera']:
            self.logger.info('Initializing camera with extra arguments')
            self.logger.debug('cam_module.camera({}, {})'.format(cam_init_arguments, self.config['Camera']['extra_args']))
            self.camera = cam_module.camera(cam_init_arguments, *self.config['Camera']['extra_args'])
        else:
            self.logger.info('Initializing camera without extra arguments')
            self.logger.debug('cam_module.camera({})'.format(cam_init_arguments))
            self.camera = cam_module.camera(cam_init_arguments)

    def set_roi(self, x, y, width, height):
        """ Sets the region of interest of the camera, provided that the camera supports cropping. All the technicalities
        should be addressed on the camera model, not in this method.

        :param int x: horizontal position for the start of the cropping
        :param int y: vertical position for the start of the cropping
        :param int width: width in pixels for cropping
        :param int height: height in pixels for the cropping
        :raises ValueError: if either dimension of the cropping goes out of the camera total amount of pixels
        :returns: The final cropping dimensions, it may be that the camera limits the user desires
        """
        pass

    def clear_roi(self):
        """ Clears the region of interest and returns to the full frame of the camera.
        """
        pass

    def snap(self):
        """ Snap a single frame
        :returns: numpy 2D array with the image (?)
        """
        self.camera.configure(self.config['camera'])
        self.snap_worker = WorkerThread(target=self.camera.snap)

    def save_image(self):
        """ Saves the last acquired image.
        """
        pass

    def start_free_run(self):
        """ Starts continuous acquisition from the camera, but it is not being saved.

        .. TODO:: Decide if this is the best strategy or it would be better to have a separate buffer method as was the  case for UUTrack.
        """
        pass

    def start_movie(self):
        """ Starts the acquisition of a movie
        """
        pass

    def stop_movie(self):
        """ Stops the acquisition of the movie.
        """
        pass

    def save_movie(self):
        """ Saves the movie to a file.
        """
        pass

    def stop_save_movie(self):
        """ Stops saving to a movie.
        """
        pass

    def empty_queue(self):
        """ Empties the queue where the data from the movie is being stored.
        """
        pass

    def get_data(self):
        """ Gets the data generated by the working thread.
        """
        pass

